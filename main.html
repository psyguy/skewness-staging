<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="MH Manuel Haqiqatkhah">

<title>Skewness and staging: Does the floor effect induce bias in multilevel AR(1) models?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="main_files/libs/clipboard/clipboard.min.js"></script>
<script src="main_files/libs/quarto-html/quarto.js"></script>
<script src="main_files/libs/quarto-html/popper.min.js"></script>
<script src="main_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="main_files/libs/quarto-html/anchor.min.js"></script>
<link href="main_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="main_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="main_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="main_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="main_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-introduction" id="toc-sec-introduction" class="nav-link active" data-scroll-target="#sec-introduction">Introduction</a></li>
  <li><a href="#sec-components" id="toc-sec-components" class="nav-link" data-scroll-target="#sec-components">Core components</a>
  <ul>
  <li><a href="#the-simulation-component" id="toc-the-simulation-component" class="nav-link" data-scroll-target="#the-simulation-component">The <em>Simulation</em> component</a>
  <ul>
  <li><a href="#data-generating-models-specifications" id="toc-data-generating-models-specifications" class="nav-link" data-scroll-target="#data-generating-models-specifications">Data-generating models specifications</a></li>
  <li><a href="#general-dgm-wrappers" id="toc-general-dgm-wrappers" class="nav-link" data-scroll-target="#general-dgm-wrappers">General DGM wrappers</a></li>
  <li><a href="#dataset-generation" id="toc-dataset-generation" class="nav-link" data-scroll-target="#dataset-generation">Dataset generation</a></li>
  </ul></li>
  <li><a href="#sec-analysis-component" id="toc-sec-analysis-component" class="nav-link" data-scroll-target="#sec-analysis-component">The <em>Analysis</em> component</a></li>
  <li><a href="#sec-harvesting-component" id="toc-sec-harvesting-component" class="nav-link" data-scroll-target="#sec-harvesting-component">The <em>Harvesting</em> component</a></li>
  <li><a href="#sec-reporting-component" id="toc-sec-reporting-component" class="nav-link" data-scroll-target="#sec-reporting-component">The <em>Reporting</em> component</a></li>
  </ul></li>
  <li><a href="#sec-pipeline" id="toc-sec-pipeline" class="nav-link" data-scroll-target="#sec-pipeline">Pipeline</a>
  <ul>
  <li><a href="#sec-book-keeping" id="toc-sec-book-keeping" class="nav-link" data-scroll-target="#sec-book-keeping">Book-keeping</a></li>
  <li><a href="#sec-pipeline-wrapper-functions" id="toc-sec-pipeline-wrapper-functions" class="nav-link" data-scroll-target="#sec-pipeline-wrapper-functions">Wrapper functions</a></li>
  <li><a href="#sec-pipeline-code" id="toc-sec-pipeline-code" class="nav-link" data-scroll-target="#sec-pipeline-code">Pipeline code</a></li>
  </ul></li>
  <li><a href="#sec-figures" id="toc-sec-figures" class="nav-link" data-scroll-target="#sec-figures">Making the figures</a>
  <ul>
  <li><a href="#simulation-results" id="toc-simulation-results" class="nav-link" data-scroll-target="#simulation-results">Simulation results</a></li>
  <li><a href="#profiles-of-simulated-datasets" id="toc-profiles-of-simulated-datasets" class="nav-link" data-scroll-target="#profiles-of-simulated-datasets">Profiles of simulated datasets</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Skewness and staging: Does the floor effect induce bias in multilevel AR(1) models?</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
<p class="subtitle lead">Reproducible codes</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>MH Manuel Haqiqatkhah </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="sec-introduction" class="level1 page-columns page-full">
<h1>Introduction</h1>
<p>This document contains the reproducible code for the manuscript Skewness and staging: Does the floor effect induce bias in multilevel AR(1) models? by M. M. Haqiqatkhah, O. Ryan, and E. L. Hamaker. please cite as:</p>
<p>…</p>
<p>In this study, we simulated multilevel data from three data generating mechanisms (DGMs), namely, the AR(1, <span class="math inline">\(\chi^2\)</span>AR(1), BinAR(1), and PoDAR(1) models with different parameter sets.<br>
For details, see the paper.</p>
<p>The simulation was conducted using the following modular pipeline design, inspired by Bien’s R package <code>simulator</code> <span class="citation" data-cites="bien_2016_SimulatorEngineStreamline">(<a href="#ref-bien_2016_SimulatorEngineStreamline" role="doc-biblioref">2016</a>)</span>, consisting of the following <strong>components</strong>:</p>
<div class="no-row-height column-margin column-container"><div id="ref-bien_2016_SimulatorEngineStreamline" class="csl-entry" role="doc-biblioentry">
Bien, Jacob. 2016. <span>“The Simulator: An Engine to Streamline Simulations.”</span> <em>arXiv:1607.00021 [Stat]</em>, June. <a href="http://arxiv.org/abs/1607.00021">http://arxiv.org/abs/1607.00021</a>.
</div></div><ol type="A">
<li><em>Simulation</em>: generating the datasets</li>
<li><em>Analysis</em>: modeling the data</li>
<li><em>Harvesting</em>: collecting the relevant parameter estimates</li>
<li><em>Reporting</em>: making tables and plots</li>
</ol>
<p>And the components were placed in a <strong>pipeline</strong>, that managed:</p>
<ol type="1">
<li>Making the simulation design matrix that include all relevant conditions</li>
<li>Book-keeping data files belonging to each replication of each condition</li>
<li>Performing simulations in batch</li>
<li>Performing Analyses in batch</li>
<li>Collecting the data in batch</li>
</ol>
<p>This document is structured as follows. In <a href="#sec-components">Section&nbsp;2</a>, we explain the four components and the functions used therein. Then, in <a href="#sec-pipeline">Section&nbsp;3</a> we explain the wrapper functions used in the pipeline, and show how the pipeline was—and can be—executed. Finally, in <a href="#sec-figures">Section&nbsp;4</a>, we discuss how the harvested data was used to make the figures used in the paper (and others that were not included).</p>
<!--# In what follows we describe the steps and provide the codes used in this study. In the other tab of this document, we provide the code to generate additional plots shown in the paper. Note that although the codes provided here are cleaned as much as possible, they are not necessarily succinctly written; some functions were written to accommodate the most general functionalities which turned out to be not necessary for the simulation study. -->
<p>Before we begin, we need to read the scripts to include them in this document. By default, none of the scripts run here (as they are time consuming). To run the scripts of each component, you can change the following variables to <code>TRUE</code> and re-render the document:</p>
<div class="cell" data-hash="main_cache/html/unnamed-chunk-1_88782f68eaeebeb2b4487fb2cd9cf442">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>runComponent_Simulation <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>runComponent_Analysis <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>runComponent_Harvesting <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>runComponent_Reporting <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In case you want to change the scripts (e.g., to run a smaller portion of the simulation, or try other parameters, etc.), you should look up the <code>kintr</code> parameters called in each chunk (with <code>&lt;&lt;some_param&gt;&gt;</code>) and find the corresponding code (under <code>## @knitr some_param</code>) in the <code>scripts</code> folder.</p>
</section>
<section id="sec-components" class="level1 page-columns page-full">
<h1>Core components</h1>
<section id="the-simulation-component" class="level2">
<h2 class="anchored" data-anchor-id="the-simulation-component">The <em>Simulation</em> component</h2>
<p>The Simulation component consists of three sets of functions:</p>
<ol type="i">
<li>Functions that implement the DGMs and generate univariate (<span class="math inline">\(N=1\)</span>) time series of length <span class="math inline">\(T\)</span> from the parameters given to them;</li>
<li>Wrappers that interface the DGM functions;</li>
<li>A wrapper to generate datasets (consisting on <span class="math inline">\(N\)</span> time series of length <span class="math inline">\(T\)</span>) with a given DGM</li>
</ol>
<section id="data-generating-models-specifications" class="level3">
<h3 class="anchored" data-anchor-id="data-generating-models-specifications">Data-generating models specifications</h3>
<p>First we define functions for each data-generating models (DGMs) that can produce univariate, single-subject (<span class="math inline">\(N=1\)</span>) time series of desired length <span class="math inline">\(T\)</span> (default: <code>T = 100</code>) with the two canonical parameters and a given random seed (default: <code>seed = 0</code>). All model(-implied) parameters are saved in a list (called <code>pa</code>).</p>
<p>For each model, the first observation (<span class="math inline">\(X_1\)</span>) is randomly drawn from the model-implied marginal distribution, to eliminate the need for removing the burn-in window in the beginning of the data. After the data is generated, in case the argument <code>only.ts</code> is set to be <code>TRUE</code>, the raw data (as a vector of length <code>T</code>) is returned. Otherwise, the function calculates empirical dynamic (<span class="math inline">\(\phi\)</span>) and marginal (<span class="math inline">\(\mu\)</span>, <span class="math inline">\(\sigma^2\)</span>, and <span class="math inline">\(\gamma\)</span>) parameters based on the simulated data, and save it in a list (<code>Empirical.Parameters</code>). Furthermore, two <span class="math inline">\(\mathrm{\LaTeX{}}\)</span>-ready strings (<code>Model.Description</code> and <code>Model.Description.Short</code>) are made which include a summary of the model parameters (that can be used, e.g., in plots). Finally, in case <code>only.ts != TRUE</code>, the function returns a list consisting of the time series (stored in <code>x</code>), verbal description of the dataset (<code>Model.Description</code> and <code>Model.Description.Short</code>), theoretical (i.e., model-implied) parameters (<code>Model.Parameters</code>), and empirical (i.e., sample) estimated parameters (<code>Empirical.Parameters</code>).</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">The AR(1) model</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false" href="">The <span class="math inline">\(\chi^2\)</span>AR(1) model</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-3" role="tab" aria-controls="tabset-1-3" aria-selected="false" href="">The BinAR(1) model</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-4-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-4" role="tab" aria-controls="tabset-1-4" aria-selected="false" href="">The PoDAR(1) model</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<p>The canonical parameters of the AR(1) model with normally distributed residuals (which we referred to as <code>NAR(1)</code> in the simulation) are the autoregressive parameter <span class="math inline">\(\phi\)</span> (default: <code>phi = 0.4</code>), mean <span class="math inline">\(\mu\)</span> (default: <code>Mean = 50</code>), and the marginal variance <span class="math inline">\(\sigma^2\)</span> (default: <code>var.marginal = 4</code>). Based on the marginal variance, the residual variance (<code>var.resid</code>) is calculated via <span class="math inline">\(\sigma^2_\epsilon = \sigma^2 (1 - \phi^2)\)</span>.</p>
<section id="construction" class="level5">
<h5 class="anchored" data-anchor-id="construction">Construction</h5>
<p>The time series is constructed by first generating a zero-centered time series <span class="math inline">\(\tilde X_t\)</span> (<code>x_cent</code>). To do so, first the initial observation in the time series (<code>x_cent[1]</code>) is sampled from normal distribution with mean zero and a variance equal to the marginal variance of the model:</p>
<p><span class="math display">\[
\tilde X_1 \sim \mathcal{N}(0, \sigma^2)
\]</span></p>
<p>Then, the remainder of the time series is generated using the definition of the AR(1) model (not that the here the residual variance is used in the normal distribution):</p>
<p><span class="math display">\[
\begin{aligned}
\tilde X_{t} &amp;= \phi \tilde X_{t-1} + \epsilon_{t} \\
\epsilon_{t} &amp;\sim \mathcal{N}(0, {\sigma^2_{\epsilon}})
\end{aligned}
\]</span> Finally, the mean is added to the centered zero-centered time series to reach the final time series with mean <span class="math inline">\(\mu\)</span>:</p>
<p><span class="math display">\[
X_t = \tilde X_t + \mu
\]</span></p>
</section>
<section id="code" class="level5">
<h5 class="anchored" data-anchor-id="code">Code</h5>
<div class="cell" data-hash="main_cache/html/unnamed-chunk-4_f9295d48d477c3e607b4b885b2e78e3c">

</div>
</section>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<p>The canonical parameters of the <span class="math inline">\(\chi^2\)</span>AR(1) model (which we referred to as <code>ChiAR(1)</code> in the simulation) are the autoregressive parameter <span class="math inline">\(\phi\)</span> (default: <code>phi = 0.4</code>), and degrees of freedom <span class="math inline">\(\nu\)</span> (default: <code>nu = 3</code>). We set the intercept to zero (<code>c = 0</code>).<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<section id="construction-1" class="level5">
<h5 class="anchored" data-anchor-id="construction-1">Construction</h5>
<p>Similar to the AR(1) model, we need to sample the first observation of the <span class="math inline">\(\chi^2\)</span>AR(1) model from its marginal distribution. However, since this model does not have a closed-form marginal distribution, as an approximation, we instead sample <code>x[1]</code> from a <span class="math inline">\(\chi^2\)</span> distribution with <span class="math inline">\(\nu\)</span> degrees of freedom:</p>
<p><span class="math display">\[
X_1 \sim \chi^2(\nu)
\]</span></p>
<p>Then, we generate the remainder of the time series using the definition of the <span class="math inline">\(\chi^2\)</span>AR(1) model:</p>
<p><span class="math display">\[
\begin{aligned}
X_{t} &amp;= c + \phi X_{t-1} + a_{t} \\
a_{t} &amp;\sim \chi^2(\nu).
\end{aligned}
\]</span></p>
</section>
<section id="code-1" class="level5">
<h5 class="anchored" data-anchor-id="code-1">Code</h5>
<div class="cell" data-hash="main_cache/html/unnamed-chunk-5_059006c6e8541e9f3bc2ff7c219cd53d">

</div>
</section>
</div>
<div id="tabset-1-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-3-tab">
<p>The canonical parameters of the BinAR(1) model (which we referred to as <code>BinAR(1)</code> in the simulation) are the survival probability <span class="math inline">\(\alpha\)</span> (default: <code>alpha = 0.5</code>) and the revival probability <span class="math inline">\(\beta\)</span> (default: <code>beta = 0.4</code>). By default, the maximum value on scale <span class="math inline">\(k\)</span> was set to <code>k = 10</code>.</p>
<section id="construction-2" class="level5">
<h5 class="anchored" data-anchor-id="construction-2">Construction</h5>
<p>We first calculate the <span class="math inline">\(\theta\)</span> parameter, which characterizes the marginal distribution of the BinaR(1) model:</p>
<p><span class="math display">\[
\theta = \frac{k \beta}{1-(\alpha-\beta)}
\]</span> Then we draw <span class="math inline">\(X_1\)</span> (<code>x[1]</code>) from the marginal distribution of the model:</p>
<p><span class="math display">\[
X_1 \sim Binom(k, \theta)
\]</span></p>
<p>The rest of time series is generated sequentially, for each time point <span class="math inline">\(t\)</span>, by drawing values for the number of survived (<code>S_t[t]</code>) and revived (<code>R_t[t]</code>) elements of the BinAR(1) model based on the previous observations (<span class="math inline">\(X_{t-1}\)</span>), and then adding them:</p>
<p><span class="math display">\[
\begin{aligned}
S_{t} &amp;\sim Binom(X_{t-1}, \alpha) \\
R_t &amp;\sim Binom(k -X_{t-1}, \beta) \\
X_{t} &amp;= S_t + R_t
\end{aligned}
\]</span></p>
</section>
<section id="code-2" class="level5">
<h5 class="anchored" data-anchor-id="code-2">Code</h5>
<div class="cell" data-hash="main_cache/html/unnamed-chunk-6_54f589f249140507571e36329883d668">

</div>
</section>
</div>
<div id="tabset-1-4" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-4-tab">
<p>The canonical parameters of the PoDAR(1) model (which we referred to as <code>PoDAR(1)</code> in the simulation) are the persistence probability <span class="math inline">\(\tau\)</span> (default: <code>tau = 0.7</code>) and the average rate <span class="math inline">\(\lambda\)</span> (default: <code>lambda = 0.5</code>).</p>
<section id="construction-3" class="level5">
<h5 class="anchored" data-anchor-id="construction-3">Construction</h5>
<p>To generate the time series, we first draw the first observation <span class="math inline">\(X_1\)</span> (<code>x[1]</code>) from a Poisson distribution with rate <span class="math inline">\(\lambda\)</span>:</p>
<p><span class="math display">\[
X_1 \sim Poisson(\lambda)
\]</span></p>
<p>And generate the rest of the time series by first drawing <span class="math inline">\(Z_t\)</span> from a Poisson distribution with rate <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(P_t\)</span> from a binomial distribution with size probability of success <span class="math inline">\(\tau\)</span> (that is equivalent to a Bernoulli distribution with probability <span class="math inline">\(\tau\)</span>). Then, we calculate <span class="math inline">\(X_t\)</span> based on the previous observation (<code>x[t-1]</code>) and values of <span class="math inline">\(Z_t\)</span> (<code>Z_t[t]</code>) and <span class="math inline">\(P_t\)</span> (<code>P_t[t]</code>), using the definition of the PoDAR(1) model:</p>
<p><span class="math display">\[
\begin{aligned}
Z_t &amp;\sim Poisson(\lambda) \\
P_t &amp;\sim Binom(1, \tau) \\
X_t &amp;= P_t X_{t-1} + (1-P_t) Z_t
\end{aligned}
\]</span></p>
</section>
<section id="code-3" class="level5">
<h5 class="anchored" data-anchor-id="code-3">Code</h5>
<div class="cell" data-hash="main_cache/html/unnamed-chunk-7_fabb81ef37d41e1c7a81553e362d6f49">

</div>
</section>
</div>
</div>
</div>
</section>
<section id="general-dgm-wrappers" class="level3">
<h3 class="anchored" data-anchor-id="general-dgm-wrappers">General DGM wrappers</h3>
<p>Given that, in each model, two canonical parameters characterize the dynamic and marginal features of the generated time series, and given that we have analytic formulas that link the canonical parameters to the model-implied <span class="math inline">\(\phi\)</span>, <span class="math inline">\(\mu\)</span>, <span class="math inline">\(\sigma^2\)</span>, and <span class="math inline">\(\gamma\)</span>, we use a function (<code>dgm_parameterizer</code>) to calculate canonical parameters from two given parameters, and make a complete list of parameters (called <code>pa</code>). This list also includes non-parameter variables, importantly, the time series length <span class="math inline">\(T\)</span> (saved in <code>pa$T</code>) and the random seed used in the <code>dgm_*</code> functions (saved in <code>pa$seed</code>). A wrapper function (<code>dgm_generator</code>) is used as an interface to all <code>dgm_*</code> functions, which first makes sure the given parameters are sufficient for data generation, makes a complete parameter list <code>pa</code> with the help of <code>dgm_parameterizer</code>, and passes <code>pa</code> to the respective DGM generating function.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-2-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-1" role="tab" aria-controls="tabset-2-1" aria-selected="true" href="">Parameter conversions</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-2-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-2" role="tab" aria-controls="tabset-2-2" aria-selected="false" href="">Wrapper around <code>dgm_*</code> functions</a></li></ul>
<div class="tab-content">
<div id="tabset-2-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-2-1-tab">
<p>The function <code>dgm_parameterizer</code> calculates canonical/model-implied parameters of a given DGM (specified using the <code>Model</code> argument) based on the parameters given to it as arguments, and saves them in a list of parameters (<code>pa</code>), which s returned by the function. The function makes sure that the set of parameters provided are sufficient to characterize the dynamic parameter of the model (i.e., the autoregression <span class="math inline">\(\phi\)</span>) and at least one of the marginal parameters (importantly, the mean <span class="math inline">\(\mu\)</span>) but giving default values to some parameters.</p>
<div class="cell" data-hash="main_cache/html/unnamed-chunk-8_eec40d04f30eb50aaf1906a01440caab">

</div>
</div>
<div id="tabset-2-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-2-2-tab">
<p>The function <code>dgm_generator</code> gets a set of parameters (either as separate arguments, or a list of parameters, like the one returned by <code>dgm_parameterizer</code>), saves them in a list called <code>pa</code>. It checks whether <span class="math inline">\(\phi\)</span> is included in the list (if not, sets the default value <code>pa$phi = 0.2</code>), and checks if at least one other parameter (which, together with <span class="math inline">\(\phi\)</span>, is required to characterize the marginal properties of the DGMs) is calculated for it (if not, it sets the default value <code>pa$Mean = 5</code> for <span class="math inline">\(\mu\)</span>). Furthermore, if the DGM name, time series length, and the random seed are not provided, it gives them default values (respectively: <code>Model = "ChiAR(1)"</code>, <code>T = 100</code>, and <code>seed = 0</code>) and adds them to <code>pa</code>.</p>
<p>Then, it passes the <code>pa</code> list to <code>dgm_parameterizer</code> to do the necessary conversions to complete the list of canonical and model-implied parameters. Finally, given the model name, it checks if non-canonical parameters <span class="math inline">\(k\)</span> and <span class="math inline">\(c\)</span> are set (otherwise assigns appropriate defaults to them), and passes the complete parameter list to the respective DGM function.</p>
<div class="cell" data-hash="main_cache/html/unnamed-chunk-9_3414344e822d142ae60bc9e13488817f">

</div>
</div>
</div>
</div>
</section>
<section id="dataset-generation" class="level3">
<h3 class="anchored" data-anchor-id="dataset-generation">Dataset generation</h3>
<p>The machinery described above can be used to generate individual (<span class="math inline">\(N=1\)</span>) time series. However, for the simulation study, we need datasets comprising of multiple (<span class="math inline">\(N=25, 50, 100\)</span>) individuals. As we discussed in the paper, in our study, all individuals in a dataset of a DGM share the same autoregressive parameter (<span class="math inline">\(\phi_i=0.4\)</span>) and the individual differences are only in the individual means (<span class="math inline">\(\mathbb{\mu} = [\mu_1 , \mu_2, \dots, \mu_N]\)</span>). Thus, we write a function (<code>dgm_make.sample</code>) that can generate, for each DGM, a dataset of <span class="math inline">\(N\)</span> individuals based on an <span class="math inline">\(N\)</span>-dimensional vector of individual means, all with the same <span class="math inline">\(\phi_i\)</span>. We then need to find the appropriate parameters for the level-2 distributions (Gaussian and <span class="math inline">\(\chi^2\)</span> distributions) for each DGM, such that the we get a considerable proportion of individuals with considerably high skewness while respecting the lower and upper bounds of values supported by each model. Finally, with a wrapper function (<code>make_datasets</code>), we facilitate making dataset by automatically generating the means vector suitable for each DGM.</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-3-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-1" role="tab" aria-controls="tabset-3-1" aria-selected="true" href="">Making individual datasets</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-3-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-2" role="tab" aria-controls="tabset-3-2" aria-selected="false" href="">Determining level-2 distribution parameters</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-3-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-3" role="tab" aria-controls="tabset-3-3" aria-selected="false" href="">Automate dataset generation</a></li></ul>
<div class="tab-content">
<div id="tabset-3-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-3-1-tab">
<p>The function <code>dgm_make.sample</code> generates a dataset of time series of length <code>T</code> with the autoregressive parameter <code>phi</code> from a desired DGM (determined by the <code>Model</code> argument) given a vector of means (passed as the argument <code>Means</code>). The length of <code>Means</code> determine the number of individuals in the dataset (<code>N &lt;- length(Means)</code>). If <code>Means</code> is not provided, a randomly generated vector of <span class="math inline">\(N = 100\)</span> is used as default. Since each individual time series is generated with a random seed, we need a vector of <code>N</code> unique seeds, which can be provided using the <code>seeds</code> argument. In case <code>seeds</code> is not provided, it is generated based on the provided means (<code>seeds.from.means</code>), and if it is a scalar, the seeds vector is created by adding the scalar to the <code>seeds.from.means</code> (which would allow generating different datasets with the same mean distributions).</p>
<div class="cell" data-hash="main_cache/html/unnamed-chunk-10_f48de9a32b15e9e83da53b32f5a06276">

</div>
</div>
<div id="tabset-3-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-3-2-tab">
<p>For each alternative DGM—the <span class="math inline">\(\chi^2\)</span>AR(1), BinAR(1), and PoDAR(1) models—we should determine appropriate parameters for the level-2 distribution of means such that we have enough skewness in the generated datasets. To do so, we make a function (<code>Mean.vs.Skewness</code>) to help us experiment with different values for <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma^2\)</span> (of the Gaussian level-2 distribution) and <span class="math inline">\(\nu\)</span> (of the <span class="math inline">\(\chi^2\)</span> level-2 distribution) for each alternative DGM. Note that we start by generating more than enough samples for each distribution (<span class="math inline">\(10 \times N\)</span>) and subsample <span class="math inline">\(N\)</span> values after applying the model-specific lower and upper bounds.</p>
<p>We notice that we get the desired distribution of skewness with the following parameters:</p>
<table class="table">
<caption>Parameters of level-2 distribution of means</caption>
<thead>
<tr class="header">
<th>Model</th>
<th><span class="math inline">\(\mu\)</span></th>
<th><span class="math inline">\(\sigma^2\)</span></th>
<th><span class="math inline">\(\nu\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\chi^2\)</span>AR(1)</td>
<td>10</td>
<td>10</td>
<td>5</td>
</tr>
<tr class="even">
<td>BinAR(1)</td>
<td>2</td>
<td>1</td>
<td>2.9</td>
</tr>
<tr class="odd">
<td>PoDAR(1)</td>
<td>4</td>
<td>4</td>
<td>1.5</td>
</tr>
</tbody>
</table>
<p>Giving us the following distributions:</p>
<p><img src="additional-files/Mean_vs_Skewness.png" class="img-fluid"></p>
</div>
<div id="tabset-3-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-3-3-tab">
<p>We then use a wrapper (<code>make_datasets</code>) around <code>dgm_make.sample</code> that generates datasets for all four DGMs with the appropriate level-2 parameters specified above. Note that here we first generate more than enough (i.e., <span class="math inline">\(2 \times N\)</span>) samples of means to make sure we end up with <span class="math inline">\(N\)</span> samples after applying the upper and lower bounds.</p>
<div class="cell" data-hash="main_cache/html/unnamed-chunk-13_7e7d462bf4ac722263655b6e8537aa7c">

</div>
</div>
</div>
</div>
</section>
</section>
<section id="sec-analysis-component" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-analysis-component">The <em>Analysis</em> component</h2>
<p>We analyzed each dataset with the AR(1) model with fixed and random residual variance using <em>M</em>plus v. 8.1 <span class="citation" data-cites="muthen_2017_MplusUserGuide">(<a href="#ref-muthen_2017_MplusUserGuide" role="doc-biblioref">Muthén and Muthén 2017</a>)</span>. To interface <em>M</em>plus from R, we used the package <code>MplusAutomation</code> <span class="citation" data-cites="hallquist_2018_MplusAutomationPackageFacilitating">(<a href="#ref-hallquist_2018_MplusAutomationPackageFacilitating" role="doc-biblioref">Hallquist and Wiley 2018</a>)</span> and wrote a function (<code>run_MplusAutomation</code>) that for each iteration of each condition would save the dataset as a <code>.dat</code> file, generate the <code>.inp</code> input script for the desired analysis type, and run the model for that dataset:</p>
<div class="no-row-height column-margin column-container"><div id="ref-muthen_2017_MplusUserGuide" class="csl-entry" role="doc-biblioentry">
Muthén, Linda K., and Bengt O. Muthén. 2017. <em>Mplus User<span>’</span>s Guide</em>. Eighth Edition. Los Angeles, CA: Muthén &amp; Muthén.
</div><div id="ref-hallquist_2018_MplusAutomationPackageFacilitating" class="csl-entry" role="doc-biblioentry">
Hallquist, Michael N., and Joshua F. Wiley. 2018. <span>“<span><em>MplusAutomation</em></span> : An R Package for Facilitating Large-Scale Latent Variable Analyses in M <span><em>Plus</em></span>.”</span> <em>Structural Equation Modeling: A Multidisciplinary Journal</em> 25 (4): 621–38. <a href="https://doi.org/10.1080/10705511.2017.1402334">https://doi.org/10.1080/10705511.2017.1402334</a>.
</div></div><div class="cell" data-hash="main_cache/html/unnamed-chunk-14_b90a237cc4a56ac1bac7e67136de4a2a">

</div>
<p>In each analysis, we simulated two MCMC chains (<code>CHAINS = 2</code>), and to reduce autocorrelation in the estimated parameters, by defining <code>THIN = 5</code> we asked <em>M</em>plus to save every 5th sample. By setting <code>BITERATIONS = 5000(2000)</code>, we made sure to have between 2000 to 5000 samples (after thinning) for each parameter from each chain. <em>M</em>plus considers the first half of each chain as burn-in samples and discards them, thus, in total, we got at least 2000 “independent” samples from both chains combined. Finally, with <code>FACTORS = ALL (500)</code> we asked <em>M</em>plus to draw 500 samples for each individuals when estimating level-1 parameters. We visually inspected the traceplots and autocorrelation plots of parameter estimates and of a sample of analyzed datasets and good convergence was observed. Furthermore, to make sure the number of iterations and thinning used in the analyses were sufficient, we re-analyzed two replications of each alternative DGM with Gaussian and <span class="math inline">\(\chi^2\)</span>-distributed means with <span class="math inline">\(N=100\)</span> and <span class="math inline">\(T=100\)</span> with <code>BITERATIONS = 12500(5000)</code> and <code>THIN = 20</code>, which led to estimates of the parameters of interest (<code>unstd X.WITH.PHI</code>, <code>unstd Variances.PHI</code>, and <code>stdyx X.WITH.PHI</code>) almost identical (up to the third decimal) to those estimated with <code>BITERATIONS = 5000(2000)</code> and <code>THIN = 5</code> (see below).</p>
<p>The generated input files looked like the following. Note that the <code>TITLE</code> and <code>DATA</code> strings in the <code>.inp</code> files are unique to the dataset being analyzed and included the unique dataset seed <code>uSeed</code> (passed to <code>make_datasets</code> to generate datasets), the number of individuals in the dataset <code>N</code>, the length of the time series <code>T</code>, the model types used (<code>resid.fixed</code> or <code>resid.random</code>), and the replication number <code>Rep</code> (see <a href="#sec-book-keeping">Section&nbsp;3.1</a> for further details).</p>
<div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-4-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-1" role="tab" aria-controls="tabset-4-1" aria-selected="true" href="">Fixed residual variance</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-4-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-2" role="tab" aria-controls="tabset-4-2" aria-selected="false" href="">Random residual variance</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-4-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-3" role="tab" aria-controls="tabset-4-3" aria-selected="false" href="">Comparing different <code>ANALYSIS</code> parameters</a></li></ul>
<div class="tab-content">
<div id="tabset-4-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-4-1-tab">
<pre><code>TITLE:
fit_uSeed-000000_N-100_T-100_type-resid.fixed_Rep-1

DATA:
FILE = "fit_uSeed-000000_N-100_T-100_type-resid.fixed_Rep-1.dat";
 
VARIABLE:
NAMES = subject t x;
MISSING=.;
CLUSTER = subject;
LAGGED = x(1);
TINTERVAL = t(1);

ANALYSIS:
TYPE = TWOLEVEL RANDOM;
ESTIMATOR = BAYES;
PROCESSORS = 1;
CHAINS = 2;
THIN = 5;
BITERATIONS = 5000(2000);

MODEL:
%WITHIN%
phi | x ON x&amp;1;
%BETWEEN%
x phi WITH x phi;

OUTPUT:
TECH1 TECH2 TECH3 TECH8 FSCOMPARISON STANDARDIZED STDYX STDY;

PLOT:
TYPE = PLOT3;
FACTORS = ALL (500)</code></pre>
</div>
<div id="tabset-4-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-4-2-tab">
<pre><code>TITLE:
fit_uSeed-000000_N-100_T-100_type-resid.random_Rep-1

DATA:
FILE = "fit_uSeed-000000_N-100_T-100_type-resid.random_Rep-1.dat";
 
VARIABLE:
NAMES = subject t x; 
MISSING=.;
CLUSTER = subject;
LAGGED = x(1);
TINTERVAL = t(1);

ANALYSIS:
TYPE = TWOLEVEL RANDOM;
ESTIMATOR = BAYES;
PROCESSORS = 1;
CHAINS = 2;
THIN = 5;
BITERATIONS = 5000(2000);

MODEL:
%WITHIN%
phi | x ON x&amp;1;
logv | x;
%BETWEEN%
x phi logv WITH x phi logv;

OUTPUT:
TECH1 TECH2 TECH3 TECH8 FSCOMPARISON STANDARDIZED STDYX STDY;

PLOT:
TYPE = PLOT3;
FACTORS = ALL (500);</code></pre>
</div>
<div id="tabset-4-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-4-3-tab">
<iframe width="700" height="500" src="./additional-files/hyperparameters.html" title="Quarto Documentation"></iframe>
</div>
</div>
</div>
</section>
<section id="sec-harvesting-component" class="level2">
<h2 class="anchored" data-anchor-id="sec-harvesting-component">The <em>Harvesting</em> component</h2>
</section>
<section id="sec-reporting-component" class="level2">
<h2 class="anchored" data-anchor-id="sec-reporting-component">The <em>Reporting</em> component</h2>
</section>
</section>
<section id="sec-pipeline" class="level1">
<h1>Pipeline</h1>
<p>We implemented each of these tasks in separate functions that were essentially wrapper functions (with parallel-computing implementation) around the modular components. Using these wrapper functions, each replication of each simulated condition was saved in a separate <code>.rds</code> file. These data files were fed to the analysis wrapper function whose output was saved in separate <code>.rds</code> data files. To collect relevant parameter estimates, another wrapper function was used to read the data files and save the desired parameters in a dataframe, which then used in reporting.</p>
<section id="sec-book-keeping" class="level2">
<h2 class="anchored" data-anchor-id="sec-book-keeping">Book-keeping</h2>
<p>The outcomes of the components are saved in separate <code>.rds</code> files and indexed by unique, descriptive names, and each replication is given a unique numeric identifier that is also used as the random seed used to generate the dataset within each replication. The file names and address are stored in two dataframes along with model parameters used to generate each dataset, and these dataframes are used when reading and writing data files in other components.</p>
</section>
<section id="sec-pipeline-wrapper-functions" class="level2">
<h2 class="anchored" data-anchor-id="sec-pipeline-wrapper-functions">Wrapper functions</h2>
</section>
<section id="sec-pipeline-code" class="level2">
<h2 class="anchored" data-anchor-id="sec-pipeline-code">Pipeline code</h2>
</section>
</section>
<section id="sec-figures" class="level1">
<h1>Making the figures</h1>
<section id="simulation-results" class="level2">
<h2 class="anchored" data-anchor-id="simulation-results">Simulation results</h2>
</section>
<section id="profiles-of-simulated-datasets" class="level2">
<h2 class="anchored" data-anchor-id="profiles-of-simulated-datasets">Profiles of simulated datasets</h2>
<!-- -->


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>The <span class="math inline">\(\chi^2\)</span>AR(1), in a more general form, can have an intercept (<span class="math inline">\(X_{t} = c + \phi X_{t-1} + a_t, \quad a_t \sim \chi^2(\nu)\)</span>. Since the intercept was set to zero in the simulation study, we discussed a zero-intercept version of this model (<span class="math inline">\(c=0\)</span>) in the paper. See the Supplemental Materials for more details.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb4" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">---</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="an">title:</span><span class="co"> "Skewness and staging: Does the floor effect induce bias in multilevel AR(1) models?"</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="an">subtitle:</span><span class="co"> "Reproducible codes"</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="an">author:</span><span class="co"> "MH Manuel Haqiqatkhah"</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="an">format:</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">  html:</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">    code-fold: true</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co">    code-tools: true</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co">    code-overflow: scroll</span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co">    code-line-numbers: true</span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co">    toc: true</span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co">    toc-location: left</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="co">    toc-depth: 5</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="co">    code-summary: "Click to expand the code"</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co">    anchor-sections: true</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="co">    reference-location: document</span></span>
<span id="cb4-17"><a href="#cb4-17"></a><span class="co">    citation-location: margin</span></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="co">  # theme:</span></span>
<span id="cb4-19"><a href="#cb4-19"></a><span class="co">  #   light: litera</span></span>
<span id="cb4-20"><a href="#cb4-20"></a><span class="co">  #   dark: darkly</span></span>
<span id="cb4-21"><a href="#cb4-21"></a><span class="co">  pdf:</span></span>
<span id="cb4-22"><a href="#cb4-22"></a><span class="co">    number-sections: true</span></span>
<span id="cb4-23"><a href="#cb4-23"></a><span class="co">    number-depth: 8</span></span>
<span id="cb4-24"><a href="#cb4-24"></a><span class="co">    toc: true</span></span>
<span id="cb4-25"><a href="#cb4-25"></a><span class="co">    toc-depth: 8</span></span>
<span id="cb4-26"><a href="#cb4-26"></a><span class="co">## For html</span></span>
<span id="cb4-27"><a href="#cb4-27"></a><span class="an">execute:</span></span>
<span id="cb4-28"><a href="#cb4-28"></a><span class="co">  enabled: true</span></span>
<span id="cb4-29"><a href="#cb4-29"></a><span class="co">  echo: true</span></span>
<span id="cb4-30"><a href="#cb4-30"></a><span class="co">  include: true</span></span>
<span id="cb4-31"><a href="#cb4-31"></a><span class="co">  warning: false</span></span>
<span id="cb4-32"><a href="#cb4-32"></a><span class="co">  error: false</span></span>
<span id="cb4-33"><a href="#cb4-33"></a><span class="co">  freeze: true</span></span>
<span id="cb4-34"><a href="#cb4-34"></a><span class="co">  cache: true</span></span>
<span id="cb4-35"><a href="#cb4-35"></a><span class="co">## For pdf</span></span>
<span id="cb4-36"><a href="#cb4-36"></a><span class="co"># execute:</span></span>
<span id="cb4-37"><a href="#cb4-37"></a><span class="co">#   enabled: true</span></span>
<span id="cb4-38"><a href="#cb4-38"></a><span class="co">#   echo: false</span></span>
<span id="cb4-39"><a href="#cb4-39"></a><span class="co">#   include: false</span></span>
<span id="cb4-40"><a href="#cb4-40"></a><span class="co">#   warning: false</span></span>
<span id="cb4-41"><a href="#cb4-41"></a><span class="co">#   error: false</span></span>
<span id="cb4-42"><a href="#cb4-42"></a><span class="an">editor:</span><span class="co"> visual</span></span>
<span id="cb4-43"><a href="#cb4-43"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb4-44"><a href="#cb4-44"></a><span class="co">---</span></span>
<span id="cb4-45"><a href="#cb4-45"></a></span>
<span id="cb4-46"><a href="#cb4-46"></a><span class="fu"># Introduction {#sec-introduction}</span></span>
<span id="cb4-47"><a href="#cb4-47"></a></span>
<span id="cb4-48"><a href="#cb4-48"></a>This document contains the reproducible code for the manuscript Skewness and staging: Does the floor effect induce bias in multilevel AR(1) models? by M. M. Haqiqatkhah, O. Ryan, and E. L. Hamaker. please cite as:</span>
<span id="cb4-49"><a href="#cb4-49"></a></span>
<span id="cb4-50"><a href="#cb4-50"></a>...</span>
<span id="cb4-51"><a href="#cb4-51"></a></span>
<span id="cb4-52"><a href="#cb4-52"></a>In this study, we simulated multilevel data from three data generating mechanisms (DGMs), namely, the AR(1, $\chi^2$AR(1), BinAR(1), and PoDAR(1) models with different parameter sets.\</span>
<span id="cb4-53"><a href="#cb4-53"></a>For details, see the paper.</span>
<span id="cb4-54"><a href="#cb4-54"></a></span>
<span id="cb4-55"><a href="#cb4-55"></a>The simulation was conducted using the following modular pipeline design, inspired by Bien's R package <span class="in">`simulator`</span> <span class="co">[</span><span class="ot">-@bien_2016_SimulatorEngineStreamline</span><span class="co">]</span>, consisting of the following **components**:</span>
<span id="cb4-56"><a href="#cb4-56"></a></span>
<span id="cb4-57"><a href="#cb4-57"></a>A.  *Simulation*: generating the datasets</span>
<span id="cb4-58"><a href="#cb4-58"></a>B.  *Analysis*: modeling the data</span>
<span id="cb4-59"><a href="#cb4-59"></a>C.  *Harvesting*: collecting the relevant parameter estimates</span>
<span id="cb4-60"><a href="#cb4-60"></a>D.  *Reporting*: making tables and plots</span>
<span id="cb4-61"><a href="#cb4-61"></a></span>
<span id="cb4-62"><a href="#cb4-62"></a>And the components were placed in a **pipeline**, that managed:</span>
<span id="cb4-63"><a href="#cb4-63"></a></span>
<span id="cb4-64"><a href="#cb4-64"></a><span class="ss">1.  </span>Making the simulation design matrix that include all relevant conditions</span>
<span id="cb4-65"><a href="#cb4-65"></a><span class="ss">2.  </span>Book-keeping data files belonging to each replication of each condition</span>
<span id="cb4-66"><a href="#cb4-66"></a><span class="ss">3.  </span>Performing simulations in batch</span>
<span id="cb4-67"><a href="#cb4-67"></a><span class="ss">4.  </span>Performing Analyses in batch</span>
<span id="cb4-68"><a href="#cb4-68"></a><span class="ss">5.  </span>Collecting the data in batch</span>
<span id="cb4-69"><a href="#cb4-69"></a></span>
<span id="cb4-70"><a href="#cb4-70"></a>This document is structured as follows. In @sec-components, we explain the four components and the functions used therein. Then, in @sec-pipeline we explain the wrapper functions used in the pipeline, and show how the pipeline was---and can be---executed. Finally, in @sec-figures, we discuss how the harvested data was used to make the figures used in the paper (and others that were not included).</span>
<span id="cb4-71"><a href="#cb4-71"></a></span>
<span id="cb4-72"><a href="#cb4-72"></a><span class="co">&lt;!--# In what follows we describe the steps and provide the codes used in this study. In the other tab of this document, we provide the code to generate additional plots shown in the paper. Note that although the codes provided here are cleaned as much as possible, they are not necessarily succinctly written; some functions were written to accommodate the most general functionalities which turned out to be not necessary for the simulation study. --&gt;</span></span>
<span id="cb4-73"><a href="#cb4-73"></a></span>
<span id="cb4-74"><a href="#cb4-74"></a>Before we begin, we need to read the scripts to include them in this document. By default, none of the scripts run here (as they are time consuming). To run the scripts of each component, you can change the following variables to <span class="in">`TRUE`</span> and re-render the document:</span>
<span id="cb4-75"><a href="#cb4-75"></a></span>
<span id="cb4-78"><a href="#cb4-78"></a><span class="in">```{r}</span></span>
<span id="cb4-79"><a href="#cb4-79"></a><span class="co">#| eval: true</span></span>
<span id="cb4-80"><a href="#cb4-80"></a><span class="co">#| code-fold: false</span></span>
<span id="cb4-81"><a href="#cb4-81"></a>runComponent_Simulation <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb4-82"><a href="#cb4-82"></a>runComponent_Analysis <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb4-83"><a href="#cb4-83"></a>runComponent_Harvesting <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb4-84"><a href="#cb4-84"></a>runComponent_Reporting <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb4-85"><a href="#cb4-85"></a><span class="in">```</span></span>
<span id="cb4-86"><a href="#cb4-86"></a></span>
<span id="cb4-87"><a href="#cb4-87"></a>In case you want to change the scripts (e.g., to run a smaller portion of the simulation, or try other parameters, etc.), you should look up the <span class="in">`kintr`</span> parameters called in each chunk (with <span class="in">`&lt;&lt;some_param&gt;&gt;`</span>) and find the corresponding code (under <span class="in">`## @knitr some_param`</span>) in the <span class="in">`scripts`</span> folder.</span>
<span id="cb4-88"><a href="#cb4-88"></a></span>
<span id="cb4-91"><a href="#cb4-91"></a><span class="in">```{r}</span></span>
<span id="cb4-92"><a href="#cb4-92"></a><span class="co">#| label: setup</span></span>
<span id="cb4-93"><a href="#cb4-93"></a><span class="co">#| echo: false</span></span>
<span id="cb4-94"><a href="#cb4-94"></a><span class="co">#| include: false</span></span>
<span id="cb4-95"><a href="#cb4-95"></a><span class="co">#| eval: true</span></span>
<span id="cb4-96"><a href="#cb4-96"></a></span>
<span id="cb4-97"><a href="#cb4-97"></a>scripts <span class="ot">&lt;-</span> <span class="fu">list.files</span>(<span class="at">path =</span> <span class="st">"scripts/"</span>,</span>
<span id="cb4-98"><a href="#cb4-98"></a>                      <span class="at">pattern =</span> <span class="st">".r|.R"</span>,</span>
<span id="cb4-99"><a href="#cb4-99"></a>                      <span class="at">full.names =</span> <span class="cn">TRUE</span>)</span>
<span id="cb4-100"><a href="#cb4-100"></a></span>
<span id="cb4-101"><a href="#cb4-101"></a><span class="fu">sapply</span>(scripts, knitr<span class="sc">::</span>read_chunk)</span>
<span id="cb4-102"><a href="#cb4-102"></a></span>
<span id="cb4-103"><a href="#cb4-103"></a>runComponent_Initialization <span class="ot">&lt;-</span> runComponent_Simulation <span class="sc">|</span> runComponent_Analysis <span class="sc">|</span> runComponent_Harvesting <span class="sc">|</span> runComponent_Reporting</span>
<span id="cb4-104"><a href="#cb4-104"></a></span>
<span id="cb4-105"><a href="#cb4-105"></a><span class="fu">library</span>(knitr)</span>
<span id="cb4-106"><a href="#cb4-106"></a></span>
<span id="cb4-107"><a href="#cb4-107"></a><span class="in">```</span></span>
<span id="cb4-108"><a href="#cb4-108"></a></span>
<span id="cb4-109"><a href="#cb4-109"></a><span class="in">```{r, eval = runComponent_Initialization}</span></span>
<span id="cb4-110"><a href="#cb4-110"></a><span class="co">#| include: false</span></span>
<span id="cb4-111"><a href="#cb4-111"></a><span class="co">#| eval: true</span></span>
<span id="cb4-112"><a href="#cb4-112"></a><span class="sc">&lt;</span><span class="er">&lt;</span>load_packages<span class="sc">&gt;</span><span class="er">&gt;</span></span>
<span id="cb4-113"><a href="#cb4-113"></a><span class="in">```</span></span>
<span id="cb4-114"><a href="#cb4-114"></a></span>
<span id="cb4-115"><a href="#cb4-115"></a><span class="fu"># Core components {#sec-components}</span></span>
<span id="cb4-116"><a href="#cb4-116"></a></span>
<span id="cb4-117"><a href="#cb4-117"></a><span class="fu">## The *Simulation* component</span></span>
<span id="cb4-118"><a href="#cb4-118"></a></span>
<span id="cb4-119"><a href="#cb4-119"></a>The Simulation component consists of three sets of functions:</span>
<span id="cb4-120"><a href="#cb4-120"></a></span>
<span id="cb4-121"><a href="#cb4-121"></a>i.  Functions that implement the DGMs and generate univariate ($N=1$) time series of length $T$ from the parameters given to them;</span>
<span id="cb4-122"><a href="#cb4-122"></a>ii. Wrappers that interface the DGM functions;</span>
<span id="cb4-123"><a href="#cb4-123"></a>iii. A wrapper to generate datasets (consisting on $N$ time series of length $T$) with a given DGM</span>
<span id="cb4-124"><a href="#cb4-124"></a></span>
<span id="cb4-125"><a href="#cb4-125"></a><span class="fu">### Data-generating models specifications</span></span>
<span id="cb4-126"><a href="#cb4-126"></a></span>
<span id="cb4-127"><a href="#cb4-127"></a>First we define functions for each data-generating models (DGMs) that can produce univariate, single-subject ($N=1$) time series of desired length $T$ (default: <span class="in">`T = 100`</span>) with the two canonical parameters and a given random seed (default: <span class="in">`seed = 0`</span>). All model(-implied) parameters are saved in a list (called <span class="in">`pa`</span>).</span>
<span id="cb4-128"><a href="#cb4-128"></a></span>
<span id="cb4-129"><a href="#cb4-129"></a>For each model, the first observation ($X_1$) is randomly drawn from the model-implied marginal distribution, to eliminate the need for removing the burn-in window in the beginning of the data. After the data is generated, in case the argument <span class="in">`only.ts`</span> is set to be <span class="in">`TRUE`</span>, the raw data (as a vector of length <span class="in">`T`</span>) is returned. Otherwise, the function calculates empirical dynamic ($\phi$) and marginal ($\mu$, $\sigma^2$, and $\gamma$) parameters based on the simulated data, and save it in a list (<span class="in">`Empirical.Parameters`</span>). Furthermore, two <span class="in">`r ifelse(knitr::is_html_output(), r"($\mathrm{\LaTeX{}}$)", r"(\LaTeX{})")`</span>-ready strings (<span class="in">`Model.Description`</span> and <span class="in">`Model.Description.Short`</span>) are made which include a summary of the model parameters (that can be used, e.g., in plots). Finally, in case <span class="in">`only.ts != TRUE`</span>, the function returns a list consisting of the time series (stored in <span class="in">`x`</span>), verbal description of the dataset (<span class="in">`Model.Description`</span> and <span class="in">`Model.Description.Short`</span>), theoretical (i.e., model-implied) parameters (<span class="in">`Model.Parameters`</span>), and empirical (i.e., sample) estimated parameters (<span class="in">`Empirical.Parameters`</span>).</span>
<span id="cb4-130"><a href="#cb4-130"></a></span>
<span id="cb4-131"><a href="#cb4-131"></a>::: panel-tabset</span>
<span id="cb4-132"><a href="#cb4-132"></a><span class="fu">#### The AR(1) model</span></span>
<span id="cb4-133"><a href="#cb4-133"></a></span>
<span id="cb4-134"><a href="#cb4-134"></a>The canonical parameters of the AR(1) model with normally distributed residuals (which we referred to as <span class="in">`NAR(1)`</span> in the simulation) are the autoregressive parameter $\phi$ (default: <span class="in">`phi = 0.4`</span>), mean $\mu$ (default: <span class="in">`Mean = 50`</span>), and the marginal variance $\sigma^2$ (default: <span class="in">`var.marginal = 4`</span>). Based on the marginal variance, the residual variance (<span class="in">`var.resid`</span>) is calculated via $\sigma^2_\epsilon = \sigma^2 (1 - \phi^2)$.</span>
<span id="cb4-135"><a href="#cb4-135"></a></span>
<span id="cb4-136"><a href="#cb4-136"></a><span class="fu">##### Construction</span></span>
<span id="cb4-137"><a href="#cb4-137"></a></span>
<span id="cb4-138"><a href="#cb4-138"></a>The time series is constructed by first generating a zero-centered time series $\tilde X_t$ (<span class="in">`x_cent`</span>). To do so, first the initial observation in the time series (<span class="in">`x_cent[1]`</span>) is sampled from normal distribution with mean zero and a variance equal to the marginal variance of the model:</span>
<span id="cb4-139"><a href="#cb4-139"></a></span>
<span id="cb4-140"><a href="#cb4-140"></a>$$</span>
<span id="cb4-141"><a href="#cb4-141"></a>\tilde X_1 \sim \mathcal{N}(0, \sigma^2)</span>
<span id="cb4-142"><a href="#cb4-142"></a>$$</span>
<span id="cb4-143"><a href="#cb4-143"></a></span>
<span id="cb4-144"><a href="#cb4-144"></a>Then, the remainder of the time series is generated using the definition of the AR(1) model (not that the here the residual variance is used in the normal distribution):</span>
<span id="cb4-145"><a href="#cb4-145"></a></span>
<span id="cb4-146"><a href="#cb4-146"></a>$$</span>
<span id="cb4-147"><a href="#cb4-147"></a>\begin{aligned}</span>
<span id="cb4-148"><a href="#cb4-148"></a>\tilde X_{t} &amp;= \phi \tilde X_{t-1} + \epsilon_{t} <span class="sc">\\</span></span>
<span id="cb4-149"><a href="#cb4-149"></a>\epsilon_{t} &amp;\sim \mathcal{N}(0, {\sigma^2_{\epsilon}})</span>
<span id="cb4-150"><a href="#cb4-150"></a>\end{aligned}</span>
<span id="cb4-151"><a href="#cb4-151"></a>$$ Finally, the mean is added to the centered zero-centered time series to reach the final time series with mean $\mu$:</span>
<span id="cb4-152"><a href="#cb4-152"></a></span>
<span id="cb4-153"><a href="#cb4-153"></a>$$</span>
<span id="cb4-154"><a href="#cb4-154"></a>X_t = \tilde X_t + \mu</span>
<span id="cb4-155"><a href="#cb4-155"></a>$$</span>
<span id="cb4-156"><a href="#cb4-156"></a></span>
<span id="cb4-157"><a href="#cb4-157"></a><span class="fu">##### Code</span></span>
<span id="cb4-158"><a href="#cb4-158"></a></span>
<span id="cb4-159"><a href="#cb4-159"></a><span class="in">```{r, eval = runComponent_Simulation}</span></span>
<span id="cb4-160"><a href="#cb4-160"></a><span class="sc">&lt;</span><span class="er">&lt;</span>dgm_nar<span class="sc">&gt;</span><span class="er">&gt;</span></span>
<span id="cb4-161"><a href="#cb4-161"></a><span class="in">```</span></span>
<span id="cb4-162"><a href="#cb4-162"></a></span>
<span id="cb4-163"><a href="#cb4-163"></a><span class="fu">#### The $\chi^2$AR(1) model</span></span>
<span id="cb4-164"><a href="#cb4-164"></a></span>
<span id="cb4-165"><a href="#cb4-165"></a>The canonical parameters of the $\chi^2$AR(1) model (which we referred to as <span class="in">`ChiAR(1)`</span> in the simulation) are the autoregressive parameter $\phi$ (default: <span class="in">`phi = 0.4`</span>), and degrees of freedom $\nu$ (default: <span class="in">`nu = 3`</span>). We set the intercept to zero (<span class="in">`c = 0`</span>).<span class="ot">[^1]</span></span>
<span id="cb4-166"><a href="#cb4-166"></a></span>
<span id="cb4-167"><a href="#cb4-167"></a><span class="fu">##### Construction</span></span>
<span id="cb4-168"><a href="#cb4-168"></a></span>
<span id="cb4-169"><a href="#cb4-169"></a>Similar to the AR(1) model, we need to sample the first observation of the $\chi^2$AR(1) model from its marginal distribution. However, since this model does not have a closed-form marginal distribution, as an approximation, we instead sample <span class="in">`x[1]`</span> from a $\chi^2$ distribution with $\nu$ degrees of freedom:</span>
<span id="cb4-170"><a href="#cb4-170"></a></span>
<span id="cb4-171"><a href="#cb4-171"></a>$$</span>
<span id="cb4-172"><a href="#cb4-172"></a>X_1 \sim \chi^2(\nu)</span>
<span id="cb4-173"><a href="#cb4-173"></a>$$</span>
<span id="cb4-174"><a href="#cb4-174"></a></span>
<span id="cb4-175"><a href="#cb4-175"></a>Then, we generate the remainder of the time series using the definition of the $\chi^2$AR(1) model:</span>
<span id="cb4-176"><a href="#cb4-176"></a></span>
<span id="cb4-177"><a href="#cb4-177"></a>$$</span>
<span id="cb4-178"><a href="#cb4-178"></a>\begin{aligned}</span>
<span id="cb4-179"><a href="#cb4-179"></a>X_{t} &amp;= c + \phi X_{t-1} + a_{t} <span class="sc">\\</span></span>
<span id="cb4-180"><a href="#cb4-180"></a>a_{t} &amp;\sim \chi^2(\nu).</span>
<span id="cb4-181"><a href="#cb4-181"></a>\end{aligned}</span>
<span id="cb4-182"><a href="#cb4-182"></a>$$</span>
<span id="cb4-183"><a href="#cb4-183"></a></span>
<span id="cb4-184"><a href="#cb4-184"></a><span class="fu">##### Code</span></span>
<span id="cb4-185"><a href="#cb4-185"></a></span>
<span id="cb4-186"><a href="#cb4-186"></a><span class="in">```{r, eval = runComponent_Simulation}</span></span>
<span id="cb4-187"><a href="#cb4-187"></a><span class="sc">&lt;</span><span class="er">&lt;</span>dgm_chiar<span class="sc">&gt;</span><span class="er">&gt;</span></span>
<span id="cb4-188"><a href="#cb4-188"></a><span class="in">```</span></span>
<span id="cb4-189"><a href="#cb4-189"></a></span>
<span id="cb4-190"><a href="#cb4-190"></a><span class="fu">#### The BinAR(1) model</span></span>
<span id="cb4-191"><a href="#cb4-191"></a></span>
<span id="cb4-192"><a href="#cb4-192"></a>The canonical parameters of the BinAR(1) model (which we referred to as <span class="in">`BinAR(1)`</span> in the simulation) are the survival probability $\alpha$ (default: <span class="in">`alpha = 0.5`</span>) and the revival probability $\beta$ (default: <span class="in">`beta = 0.4`</span>). By default, the maximum value on scale $k$ was set to <span class="in">`k = 10`</span>.</span>
<span id="cb4-193"><a href="#cb4-193"></a></span>
<span id="cb4-194"><a href="#cb4-194"></a><span class="fu">##### Construction</span></span>
<span id="cb4-195"><a href="#cb4-195"></a></span>
<span id="cb4-196"><a href="#cb4-196"></a>We first calculate the $\theta$ parameter, which characterizes the marginal distribution of the BinaR(1) model:</span>
<span id="cb4-197"><a href="#cb4-197"></a></span>
<span id="cb4-198"><a href="#cb4-198"></a>$$</span>
<span id="cb4-199"><a href="#cb4-199"></a>\theta = \frac{k \beta}{1-(\alpha-\beta)}</span>
<span id="cb4-200"><a href="#cb4-200"></a>$$ Then we draw $X_1$ (<span class="in">`x[1]`</span>) from the marginal distribution of the model:</span>
<span id="cb4-201"><a href="#cb4-201"></a></span>
<span id="cb4-202"><a href="#cb4-202"></a>$$</span>
<span id="cb4-203"><a href="#cb4-203"></a>X_1 \sim Binom(k, \theta)</span>
<span id="cb4-204"><a href="#cb4-204"></a>$$</span>
<span id="cb4-205"><a href="#cb4-205"></a></span>
<span id="cb4-206"><a href="#cb4-206"></a>The rest of time series is generated sequentially, for each time point $t$, by drawing values for the number of survived (<span class="in">`S_t[t]`</span>) and revived (<span class="in">`R_t[t]`</span>) elements of the BinAR(1) model based on the previous observations ($X_{t-1}$), and then adding them:</span>
<span id="cb4-207"><a href="#cb4-207"></a></span>
<span id="cb4-208"><a href="#cb4-208"></a>$$</span>
<span id="cb4-209"><a href="#cb4-209"></a>\begin{aligned}</span>
<span id="cb4-210"><a href="#cb4-210"></a>S_{t} &amp;\sim Binom(X_{t-1}, \alpha) <span class="sc">\\</span></span>
<span id="cb4-211"><a href="#cb4-211"></a>R_t &amp;\sim Binom(k -X_{t-1}, \beta) <span class="sc">\\</span></span>
<span id="cb4-212"><a href="#cb4-212"></a>X_{t} &amp;= S_t + R_t</span>
<span id="cb4-213"><a href="#cb4-213"></a>\end{aligned}</span>
<span id="cb4-214"><a href="#cb4-214"></a>$$</span>
<span id="cb4-215"><a href="#cb4-215"></a></span>
<span id="cb4-216"><a href="#cb4-216"></a><span class="fu">##### Code</span></span>
<span id="cb4-217"><a href="#cb4-217"></a></span>
<span id="cb4-218"><a href="#cb4-218"></a><span class="in">```{r, eval = runComponent_Simulation}</span></span>
<span id="cb4-219"><a href="#cb4-219"></a><span class="sc">&lt;</span><span class="er">&lt;</span>dgm_binar<span class="sc">&gt;</span><span class="er">&gt;</span></span>
<span id="cb4-220"><a href="#cb4-220"></a><span class="in">```</span></span>
<span id="cb4-221"><a href="#cb4-221"></a></span>
<span id="cb4-222"><a href="#cb4-222"></a><span class="fu">#### The PoDAR(1) model</span></span>
<span id="cb4-223"><a href="#cb4-223"></a></span>
<span id="cb4-224"><a href="#cb4-224"></a>The canonical parameters of the PoDAR(1) model (which we referred to as <span class="in">`PoDAR(1)`</span> in the simulation) are the persistence probability $\tau$ (default: <span class="in">`tau = 0.7`</span>) and the average rate $\lambda$ (default: <span class="in">`lambda = 0.5`</span>).</span>
<span id="cb4-225"><a href="#cb4-225"></a></span>
<span id="cb4-226"><a href="#cb4-226"></a><span class="fu">##### Construction</span></span>
<span id="cb4-227"><a href="#cb4-227"></a></span>
<span id="cb4-228"><a href="#cb4-228"></a>To generate the time series, we first draw the first observation $X_1$ (<span class="in">`x[1]`</span>) from a Poisson distribution with rate $\lambda$:</span>
<span id="cb4-229"><a href="#cb4-229"></a></span>
<span id="cb4-230"><a href="#cb4-230"></a>$$</span>
<span id="cb4-231"><a href="#cb4-231"></a>X_1 \sim Poisson(\lambda)</span>
<span id="cb4-232"><a href="#cb4-232"></a>$$</span>
<span id="cb4-233"><a href="#cb4-233"></a></span>
<span id="cb4-234"><a href="#cb4-234"></a>And generate the rest of the time series by first drawing $Z_t$ from a Poisson distribution with rate $\lambda$ and $P_t$ from a binomial distribution with size probability of success $\tau$ (that is equivalent to a Bernoulli distribution with probability $\tau$). Then, we calculate $X_t$ based on the previous observation (<span class="in">`x[t-1]`</span>) and values of $Z_t$ (<span class="in">`Z_t[t]`</span>) and $P_t$ (<span class="in">`P_t[t]`</span>), using the definition of the PoDAR(1) model:</span>
<span id="cb4-235"><a href="#cb4-235"></a></span>
<span id="cb4-236"><a href="#cb4-236"></a>$$</span>
<span id="cb4-237"><a href="#cb4-237"></a>\begin{aligned}</span>
<span id="cb4-238"><a href="#cb4-238"></a>Z_t &amp;\sim Poisson(\lambda) <span class="sc">\\</span></span>
<span id="cb4-239"><a href="#cb4-239"></a>P_t &amp;\sim Binom(1, \tau) <span class="sc">\\</span></span>
<span id="cb4-240"><a href="#cb4-240"></a>X_t &amp;= P_t X_{t-1} + (1-P_t) Z_t</span>
<span id="cb4-241"><a href="#cb4-241"></a>\end{aligned}</span>
<span id="cb4-242"><a href="#cb4-242"></a>$$</span>
<span id="cb4-243"><a href="#cb4-243"></a></span>
<span id="cb4-244"><a href="#cb4-244"></a><span class="fu">##### Code</span></span>
<span id="cb4-245"><a href="#cb4-245"></a></span>
<span id="cb4-246"><a href="#cb4-246"></a><span class="in">```{r, eval = runComponent_Simulation}</span></span>
<span id="cb4-247"><a href="#cb4-247"></a><span class="sc">&lt;</span><span class="er">&lt;</span>dgm_podar<span class="sc">&gt;</span><span class="er">&gt;</span></span>
<span id="cb4-248"><a href="#cb4-248"></a><span class="in">```</span></span>
<span id="cb4-249"><a href="#cb4-249"></a>:::</span>
<span id="cb4-250"><a href="#cb4-250"></a></span>
<span id="cb4-251"><a href="#cb4-251"></a><span class="ot">[^1]: </span>The $\chi^2$AR(1), in a more general form, can have an intercept ($X_{t} = c + \phi X_{t-1} + a_t, \quad a_t \sim \chi^2(\nu)$. Since the intercept was set to zero in the simulation study, we discussed a zero-intercept version of this model ($c=0$) in the paper. See the Supplemental Materials for more details.</span>
<span id="cb4-252"><a href="#cb4-252"></a></span>
<span id="cb4-253"><a href="#cb4-253"></a><span class="fu">### General DGM wrappers</span></span>
<span id="cb4-254"><a href="#cb4-254"></a></span>
<span id="cb4-255"><a href="#cb4-255"></a>Given that, in each model, two canonical parameters characterize the dynamic and marginal features of the generated time series, and given that we have analytic formulas that link the canonical parameters to the model-implied $\phi$, $\mu$, $\sigma^2$, and $\gamma$, we use a function (<span class="in">`dgm_parameterizer`</span>) to calculate canonical parameters from two given parameters, and make a complete list of parameters (called <span class="in">`pa`</span>). This list also includes non-parameter variables, importantly, the time series length $T$ (saved in <span class="in">`pa$T`</span>) and the random seed used in the <span class="in">`dgm_*`</span> functions (saved in <span class="in">`pa$seed`</span>). A wrapper function (<span class="in">`dgm_generator`</span>) is used as an interface to all <span class="in">`dgm_*`</span> functions, which first makes sure the given parameters are sufficient for data generation, makes a complete parameter list <span class="in">`pa`</span> with the help of <span class="in">`dgm_parameterizer`</span>, and passes <span class="in">`pa`</span> to the respective DGM generating function.</span>
<span id="cb4-256"><a href="#cb4-256"></a></span>
<span id="cb4-257"><a href="#cb4-257"></a>::: panel-tabset</span>
<span id="cb4-258"><a href="#cb4-258"></a><span class="fu">#### Parameter conversions</span></span>
<span id="cb4-259"><a href="#cb4-259"></a></span>
<span id="cb4-260"><a href="#cb4-260"></a>The function <span class="in">`dgm_parameterizer`</span> calculates canonical/model-implied parameters of a given DGM (specified using the <span class="in">`Model`</span> argument) based on the parameters given to it as arguments, and saves them in a list of parameters (<span class="in">`pa`</span>), which s returned by the function. The function makes sure that the set of parameters provided are sufficient to characterize the dynamic parameter of the model (i.e., the autoregression $\phi$) and at least one of the marginal parameters (importantly, the mean $\mu$) but giving default values to some parameters.</span>
<span id="cb4-261"><a href="#cb4-261"></a></span>
<span id="cb4-262"><a href="#cb4-262"></a><span class="in">```{r, eval = runComponent_Simulation}</span></span>
<span id="cb4-263"><a href="#cb4-263"></a><span class="sc">&lt;</span><span class="er">&lt;</span>dgm_parameterizer<span class="sc">&gt;</span><span class="er">&gt;</span></span>
<span id="cb4-264"><a href="#cb4-264"></a><span class="in">```</span></span>
<span id="cb4-265"><a href="#cb4-265"></a></span>
<span id="cb4-266"><a href="#cb4-266"></a><span class="fu">#### Wrapper around `dgm_*` functions</span></span>
<span id="cb4-267"><a href="#cb4-267"></a></span>
<span id="cb4-268"><a href="#cb4-268"></a>The function <span class="in">`dgm_generator`</span> gets a set of parameters (either as separate arguments, or a list of parameters, like the one returned by <span class="in">`dgm_parameterizer`</span>), saves them in a list called <span class="in">`pa`</span>. It checks whether $\phi$ is included in the list (if not, sets the default value <span class="in">`pa$phi = 0.2`</span>), and checks if at least one other parameter (which, together with $\phi$, is required to characterize the marginal properties of the DGMs) is calculated for it (if not, it sets the default value <span class="in">`pa$Mean = 5`</span> for $\mu$). Furthermore, if the DGM name, time series length, and the random seed are not provided, it gives them default values (respectively: <span class="in">`Model = "ChiAR(1)"`</span>, <span class="in">`T = 100`</span>, and <span class="in">`seed = 0`</span>) and adds them to <span class="in">`pa`</span>.</span>
<span id="cb4-269"><a href="#cb4-269"></a></span>
<span id="cb4-270"><a href="#cb4-270"></a>Then, it passes the <span class="in">`pa`</span> list to <span class="in">`dgm_parameterizer`</span> to do the necessary conversions to complete the list of canonical and model-implied parameters. Finally, given the model name, it checks if non-canonical parameters $k$ and $c$ are set (otherwise assigns appropriate defaults to them), and passes the complete parameter list to the respective DGM function.</span>
<span id="cb4-271"><a href="#cb4-271"></a></span>
<span id="cb4-272"><a href="#cb4-272"></a><span class="in">```{r, eval = runComponent_Simulation}</span></span>
<span id="cb4-273"><a href="#cb4-273"></a><span class="sc">&lt;</span><span class="er">&lt;</span>dgm_generator<span class="sc">&gt;</span><span class="er">&gt;</span></span>
<span id="cb4-274"><a href="#cb4-274"></a><span class="in">```</span></span>
<span id="cb4-275"><a href="#cb4-275"></a>:::</span>
<span id="cb4-276"><a href="#cb4-276"></a></span>
<span id="cb4-277"><a href="#cb4-277"></a><span class="fu">### Dataset generation</span></span>
<span id="cb4-278"><a href="#cb4-278"></a></span>
<span id="cb4-279"><a href="#cb4-279"></a>The machinery described above can be used to generate individual ($N=1$) time series. However, for the simulation study, we need datasets comprising of multiple ($N=25, 50, 100$) individuals. As we discussed in the paper, in our study, all individuals in a dataset of a DGM share the same autoregressive parameter ($\phi_i=0.4$) and the individual differences are only in the individual means ($\mathbb{\mu} = <span class="co">[</span><span class="ot">\mu_1 , \mu_2, \dots, \mu_N</span><span class="co">]</span>$). Thus, we write a function (<span class="in">`dgm_make.sample`</span>) that can generate, for each DGM, a dataset of $N$ individuals based on an $N$-dimensional vector of individual means, all with the same $\phi_i$. We then need to find the appropriate parameters for the level-2 distributions (Gaussian and $\chi^2$ distributions) for each DGM, such that the we get a considerable proportion of individuals with considerably high skewness while respecting the lower and upper bounds of values supported by each model. Finally, with a wrapper function (<span class="in">`make_datasets`</span>), we facilitate making dataset by automatically generating the means vector suitable for each DGM.</span>
<span id="cb4-280"><a href="#cb4-280"></a></span>
<span id="cb4-281"><a href="#cb4-281"></a>::: panel-tabset</span>
<span id="cb4-282"><a href="#cb4-282"></a><span class="fu">#### Making individual datasets</span></span>
<span id="cb4-283"><a href="#cb4-283"></a></span>
<span id="cb4-284"><a href="#cb4-284"></a>The function <span class="in">`dgm_make.sample`</span> generates a dataset of time series of length <span class="in">`T`</span> with the autoregressive parameter <span class="in">`phi`</span> from a desired DGM (determined by the <span class="in">`Model`</span> argument) given a vector of means (passed as the argument <span class="in">`Means`</span>). The length of <span class="in">`Means`</span> determine the number of individuals in the dataset (<span class="in">`N &lt;- length(Means)`</span>). If <span class="in">`Means`</span> is not provided, a randomly generated vector of $N = 100$ is used as default. Since each individual time series is generated with a random seed, we need a vector of <span class="in">`N`</span> unique seeds, which can be provided using the <span class="in">`seeds`</span> argument. In case <span class="in">`seeds`</span> is not provided, it is generated based on the provided means (<span class="in">`seeds.from.means`</span>), and if it is a scalar, the seeds vector is created by adding the scalar to the <span class="in">`seeds.from.means`</span> (which would allow generating different datasets with the same mean distributions).</span>
<span id="cb4-285"><a href="#cb4-285"></a></span>
<span id="cb4-286"><a href="#cb4-286"></a><span class="in">```{r, eval = runComponent_Simulation}</span></span>
<span id="cb4-287"><a href="#cb4-287"></a><span class="sc">&lt;</span><span class="er">&lt;</span>dgm_make.sample<span class="sc">&gt;</span><span class="er">&gt;</span></span>
<span id="cb4-288"><a href="#cb4-288"></a><span class="in">```</span></span>
<span id="cb4-289"><a href="#cb4-289"></a></span>
<span id="cb4-290"><a href="#cb4-290"></a><span class="fu">#### Determining level-2 distribution parameters</span></span>
<span id="cb4-291"><a href="#cb4-291"></a></span>
<span id="cb4-292"><a href="#cb4-292"></a>For each alternative DGM---the $\chi^2$AR(1), BinAR(1), and PoDAR(1) models---we should determine appropriate parameters for the level-2 distribution of means such that we have enough skewness in the generated datasets. To do so, we make a function (<span class="in">`Mean.vs.Skewness`</span>) to help us experiment with different values for $\mu$ and $\sigma^2$ (of the Gaussian level-2 distribution) and $\nu$ (of the $\chi^2$ level-2 distribution) for each alternative DGM. Note that we start by generating more than enough samples for each distribution ($10 \times N$) and subsample $N$ values after applying the model-specific lower and upper bounds.</span>
<span id="cb4-293"><a href="#cb4-293"></a></span>
<span id="cb4-296"><a href="#cb4-296"></a><span class="in">```{r}</span></span>
<span id="cb4-297"><a href="#cb4-297"></a><span class="co">#| eval: true</span></span>
<span id="cb4-298"><a href="#cb4-298"></a><span class="co">#| echo: false</span></span>
<span id="cb4-299"><a href="#cb4-299"></a><span class="co">#| include: false</span></span>
<span id="cb4-300"><a href="#cb4-300"></a><span class="sc">&lt;</span><span class="er">&lt;</span>Mean.vs.Skewness<span class="sc">&gt;</span><span class="er">&gt;</span></span>
<span id="cb4-301"><a href="#cb4-301"></a><span class="in">```</span></span>
<span id="cb4-302"><a href="#cb4-302"></a></span>
<span id="cb4-303"><a href="#cb4-303"></a>We notice that we get the desired distribution of skewness with the following parameters:</span>
<span id="cb4-304"><a href="#cb4-304"></a></span>
<span id="cb4-305"><a href="#cb4-305"></a>| Model         | $\mu$ | $\sigma^2$ | $\nu$ |</span>
<span id="cb4-306"><a href="#cb4-306"></a>|---------------|-------|------------|-------|</span>
<span id="cb4-307"><a href="#cb4-307"></a>| $\chi^2$AR(1) | 10    | 10         | 5     |</span>
<span id="cb4-308"><a href="#cb4-308"></a>| BinAR(1)      | 2     | 1          | 2.9   |</span>
<span id="cb4-309"><a href="#cb4-309"></a>| PoDAR(1)      | 4     | 4          | 1.5   |</span>
<span id="cb4-310"><a href="#cb4-310"></a></span>
<span id="cb4-311"><a href="#cb4-311"></a>: Parameters of level-2 distribution of means</span>
<span id="cb4-312"><a href="#cb4-312"></a></span>
<span id="cb4-313"><a href="#cb4-313"></a>Giving us the following distributions:</span>
<span id="cb4-314"><a href="#cb4-314"></a></span>
<span id="cb4-317"><a href="#cb4-317"></a><span class="in">```{r}</span></span>
<span id="cb4-318"><a href="#cb4-318"></a><span class="co">#| eval: false</span></span>
<span id="cb4-319"><a href="#cb4-319"></a><span class="co">#| echo: false</span></span>
<span id="cb4-320"><a href="#cb4-320"></a><span class="co">#| include: false</span></span>
<span id="cb4-321"><a href="#cb4-321"></a></span>
<span id="cb4-322"><a href="#cb4-322"></a></span>
<span id="cb4-323"><a href="#cb4-323"></a>gaussian.means <span class="ot">&lt;-</span></span>
<span id="cb4-324"><a href="#cb4-324"></a>  <span class="fu">wrap_elements</span>(<span class="fu">Mean.vs.Skewness</span>(<span class="st">"Chi2AR"</span>,</span>
<span id="cb4-325"><a href="#cb4-325"></a>     <span class="at">l2.mean =</span> <span class="dv">10</span>,</span>
<span id="cb4-326"><a href="#cb4-326"></a>     <span class="at">l2.var =</span> <span class="dv">10</span>,</span>
<span id="cb4-327"><a href="#cb4-327"></a>     <span class="at">seed =</span> <span class="dv">1</span>)) <span class="sc">/</span></span>
<span id="cb4-328"><a href="#cb4-328"></a>  <span class="fu">wrap_elements</span>(<span class="fu">Mean.vs.Skewness</span>(<span class="st">"BinAR"</span>,</span>
<span id="cb4-329"><a href="#cb4-329"></a>     <span class="at">l2.mean =</span> <span class="dv">2</span>,</span>
<span id="cb4-330"><a href="#cb4-330"></a>     <span class="at">l2.var =</span> <span class="dv">1</span>,</span>
<span id="cb4-331"><a href="#cb4-331"></a>     <span class="at">seed =</span> <span class="dv">4</span>)) <span class="sc">/</span></span>
<span id="cb4-332"><a href="#cb4-332"></a>  <span class="fu">wrap_elements</span>(<span class="fu">Mean.vs.Skewness</span>(<span class="st">"PoDAR"</span>,</span>
<span id="cb4-333"><a href="#cb4-333"></a>                   <span class="at">l2.mean =</span> <span class="dv">4</span>,</span>
<span id="cb4-334"><a href="#cb4-334"></a>     <span class="at">seed =</span> <span class="dv">2</span>))</span>
<span id="cb4-335"><a href="#cb4-335"></a></span>
<span id="cb4-336"><a href="#cb4-336"></a>chi2.means <span class="ot">&lt;-</span></span>
<span id="cb4-337"><a href="#cb4-337"></a>  <span class="fu">wrap_elements</span>(<span class="fu">Mean.vs.Skewness</span>(<span class="st">"Chi2AR"</span>,</span>
<span id="cb4-338"><a href="#cb4-338"></a>     <span class="at">chi2.df =</span> <span class="dv">5</span>,</span>
<span id="cb4-339"><a href="#cb4-339"></a>     <span class="at">seed =</span> <span class="dv">1</span>)) <span class="sc">/</span></span>
<span id="cb4-340"><a href="#cb4-340"></a>  <span class="fu">wrap_elements</span>(<span class="fu">Mean.vs.Skewness</span>(<span class="st">"BinAR"</span>,</span>
<span id="cb4-341"><a href="#cb4-341"></a>     <span class="at">chi2.df =</span> <span class="fl">2.9</span>,</span>
<span id="cb4-342"><a href="#cb4-342"></a>     <span class="at">seed =</span> <span class="dv">1</span>)) <span class="sc">/</span></span>
<span id="cb4-343"><a href="#cb4-343"></a>  <span class="fu">wrap_elements</span>(<span class="fu">Mean.vs.Skewness</span>(<span class="st">"PoDAR"</span>,</span>
<span id="cb4-344"><a href="#cb4-344"></a>                   <span class="at">chi2.df =</span> <span class="fl">1.5</span>,</span>
<span id="cb4-345"><a href="#cb4-345"></a>     <span class="at">seed =</span> <span class="dv">4</span>))</span>
<span id="cb4-346"><a href="#cb4-346"></a></span>
<span id="cb4-347"><a href="#cb4-347"></a><span class="fu">ggsave</span>(<span class="st">"Mean_vs_Skewness.png"</span>,</span>
<span id="cb4-348"><a href="#cb4-348"></a>       <span class="fu">wrap_elements</span>(gaussian.means) <span class="sc">+</span></span>
<span id="cb4-349"><a href="#cb4-349"></a>       <span class="fu">wrap_elements</span>(chi2.means),</span>
<span id="cb4-350"><a href="#cb4-350"></a>       <span class="at">path =</span> <span class="st">"additional-files"</span>,</span>
<span id="cb4-351"><a href="#cb4-351"></a>       <span class="at">width =</span> <span class="dv">40</span>,</span>
<span id="cb4-352"><a href="#cb4-352"></a>       <span class="at">height =</span> <span class="dv">60</span>,</span>
<span id="cb4-353"><a href="#cb4-353"></a>       <span class="at">units =</span> <span class="st">"cm"</span>)</span>
<span id="cb4-354"><a href="#cb4-354"></a><span class="in">```</span></span>
<span id="cb4-355"><a href="#cb4-355"></a></span>
<span id="cb4-356"><a href="#cb4-356"></a><span class="al">![](additional-files/Mean_vs_Skewness.png)</span></span>
<span id="cb4-357"><a href="#cb4-357"></a></span>
<span id="cb4-358"><a href="#cb4-358"></a><span class="fu">#### Automate dataset generation</span></span>
<span id="cb4-359"><a href="#cb4-359"></a></span>
<span id="cb4-360"><a href="#cb4-360"></a>We then use a wrapper (<span class="in">`make_datasets`</span>) around <span class="in">`dgm_make.sample`</span> that generates datasets for all four DGMs with the appropriate level-2 parameters specified above. Note that here we first generate more than enough (i.e., $2 \times N$) samples of means to make sure we end up with $N$ samples after applying the upper and lower bounds.</span>
<span id="cb4-361"><a href="#cb4-361"></a></span>
<span id="cb4-362"><a href="#cb4-362"></a><span class="in">```{r, eval = runComponent_Simulation}</span></span>
<span id="cb4-363"><a href="#cb4-363"></a><span class="sc">&lt;</span><span class="er">&lt;</span>make_datasets<span class="sc">&gt;</span><span class="er">&gt;</span></span>
<span id="cb4-364"><a href="#cb4-364"></a><span class="in">```</span></span>
<span id="cb4-365"><a href="#cb4-365"></a>:::</span>
<span id="cb4-366"><a href="#cb4-366"></a></span>
<span id="cb4-367"><a href="#cb4-367"></a><span class="fu">## The *Analysis* component {#sec-analysis-component}</span></span>
<span id="cb4-368"><a href="#cb4-368"></a></span>
<span id="cb4-369"><a href="#cb4-369"></a>We analyzed each dataset with the AR(1) model with fixed and random residual variance using *M*plus v. 8.1 [@muthen_2017_MplusUserGuide]. To interface *M*plus from R, we used the package <span class="in">`MplusAutomation`</span> <span class="co">[</span><span class="ot">@hallquist_2018_MplusAutomationPackageFacilitating</span><span class="co">]</span> and wrote a function (<span class="in">`run_MplusAutomation`</span>) that for each iteration of each condition would save the dataset as a <span class="in">`.dat`</span> file, generate the <span class="in">`.inp`</span> input script for the desired analysis type, and run the model for that dataset:</span>
<span id="cb4-370"><a href="#cb4-370"></a></span>
<span id="cb4-371"><a href="#cb4-371"></a><span class="in">```{r, eval = runComponent_Simulation}</span></span>
<span id="cb4-372"><a href="#cb4-372"></a><span class="sc">&lt;</span><span class="er">&lt;</span>run_MplusAutomation<span class="sc">&gt;</span><span class="er">&gt;</span></span>
<span id="cb4-373"><a href="#cb4-373"></a><span class="in">```</span></span>
<span id="cb4-374"><a href="#cb4-374"></a></span>
<span id="cb4-375"><a href="#cb4-375"></a>In each analysis, we simulated two MCMC chains (<span class="in">`CHAINS = 2`</span>), and to reduce autocorrelation in the estimated parameters, by defining <span class="in">`THIN = 5`</span> we asked *M*plus to save every 5th sample. By setting `BITERATIONS = 5000(2000)`, we made sure to have between 2000 to 5000 samples (after thinning) for each parameter from each chain. *M*plus considers the first half of each chain as burn-in samples and discards them, thus, in total, we got at least 2000 "independent" samples from both chains combined. Finally, with `FACTORS = ALL (500)` we asked *M*plus to draw 500 samples for each individuals when estimating level-1 parameters. We visually inspected the traceplots and autocorrelation plots of parameter estimates and of a sample of analyzed datasets and good convergence was observed. Furthermore, to make sure the number of iterations and thinning used in the analyses were sufficient, we re-analyzed two replications of each alternative DGM with Gaussian and $\chi^2$-distributed means with $N=100$ and $T=100$ with <span class="in">`BITERATIONS = 12500(5000)`</span> and <span class="in">`THIN = 20`</span>, which led to estimates of the parameters of interest (<span class="in">`unstd X.WITH.PHI`</span>, <span class="in">`unstd Variances.PHI`</span>, and <span class="in">`stdyx X.WITH.PHI`</span>) almost identical (up to the third decimal) to those estimated with <span class="in">`BITERATIONS = 5000(2000)`</span> and <span class="in">`THIN = 5`</span> (see below).</span>
<span id="cb4-376"><a href="#cb4-376"></a></span>
<span id="cb4-377"><a href="#cb4-377"></a>The generated input files looked like the following. Note that the <span class="in">`TITLE`</span> and <span class="in">`DATA`</span> strings in the <span class="in">`.inp`</span> files are unique to the dataset being analyzed and included the unique dataset seed <span class="in">`uSeed`</span> (passed to <span class="in">`make_datasets`</span> to generate datasets), the number of individuals in the dataset <span class="in">`N`</span>, the length of the time series <span class="in">`T`</span>, the model types used (<span class="in">`resid.fixed`</span> or <span class="in">`resid.random`</span>), and the replication number <span class="in">`Rep`</span> (see @sec-book-keeping for further details).</span>
<span id="cb4-378"><a href="#cb4-378"></a></span>
<span id="cb4-379"><a href="#cb4-379"></a>::: panel-tabset</span>
<span id="cb4-380"><a href="#cb4-380"></a><span class="fu">#### Fixed residual variance</span></span>
<span id="cb4-381"><a href="#cb4-381"></a></span>
<span id="cb4-382"><a href="#cb4-382"></a><span class="in">    TITLE:</span></span>
<span id="cb4-383"><a href="#cb4-383"></a><span class="in">    fit_uSeed-000000_N-100_T-100_type-resid.fixed_Rep-1</span></span>
<span id="cb4-384"><a href="#cb4-384"></a></span>
<span id="cb4-385"><a href="#cb4-385"></a><span class="in">    DATA:</span></span>
<span id="cb4-386"><a href="#cb4-386"></a><span class="in">    FILE = "fit_uSeed-000000_N-100_T-100_type-resid.fixed_Rep-1.dat";</span></span>
<span id="cb4-387"><a href="#cb4-387"></a><span class="in">     </span></span>
<span id="cb4-388"><a href="#cb4-388"></a><span class="in">    VARIABLE:</span></span>
<span id="cb4-389"><a href="#cb4-389"></a><span class="in">    NAMES = subject t x;</span></span>
<span id="cb4-390"><a href="#cb4-390"></a><span class="in">    MISSING=.;</span></span>
<span id="cb4-391"><a href="#cb4-391"></a><span class="in">    CLUSTER = subject;</span></span>
<span id="cb4-392"><a href="#cb4-392"></a><span class="in">    LAGGED = x(1);</span></span>
<span id="cb4-393"><a href="#cb4-393"></a><span class="in">    TINTERVAL = t(1);</span></span>
<span id="cb4-394"><a href="#cb4-394"></a></span>
<span id="cb4-395"><a href="#cb4-395"></a><span class="in">    ANALYSIS:</span></span>
<span id="cb4-396"><a href="#cb4-396"></a><span class="in">    TYPE = TWOLEVEL RANDOM;</span></span>
<span id="cb4-397"><a href="#cb4-397"></a><span class="in">    ESTIMATOR = BAYES;</span></span>
<span id="cb4-398"><a href="#cb4-398"></a><span class="in">    PROCESSORS = 1;</span></span>
<span id="cb4-399"><a href="#cb4-399"></a><span class="in">    CHAINS = 2;</span></span>
<span id="cb4-400"><a href="#cb4-400"></a><span class="in">    THIN = 5;</span></span>
<span id="cb4-401"><a href="#cb4-401"></a><span class="in">    BITERATIONS = 5000(2000);</span></span>
<span id="cb4-402"><a href="#cb4-402"></a></span>
<span id="cb4-403"><a href="#cb4-403"></a><span class="in">    MODEL:</span></span>
<span id="cb4-404"><a href="#cb4-404"></a><span class="in">    %WITHIN%</span></span>
<span id="cb4-405"><a href="#cb4-405"></a><span class="in">    phi | x ON x&amp;1;</span></span>
<span id="cb4-406"><a href="#cb4-406"></a><span class="in">    %BETWEEN%</span></span>
<span id="cb4-407"><a href="#cb4-407"></a><span class="in">    x phi WITH x phi;</span></span>
<span id="cb4-408"><a href="#cb4-408"></a></span>
<span id="cb4-409"><a href="#cb4-409"></a><span class="in">    OUTPUT:</span></span>
<span id="cb4-410"><a href="#cb4-410"></a><span class="in">    TECH1 TECH2 TECH3 TECH8 FSCOMPARISON STANDARDIZED STDYX STDY;</span></span>
<span id="cb4-411"><a href="#cb4-411"></a></span>
<span id="cb4-412"><a href="#cb4-412"></a><span class="in">    PLOT:</span></span>
<span id="cb4-413"><a href="#cb4-413"></a><span class="in">    TYPE = PLOT3;</span></span>
<span id="cb4-414"><a href="#cb4-414"></a><span class="in">    FACTORS = ALL (500)</span></span>
<span id="cb4-415"><a href="#cb4-415"></a></span>
<span id="cb4-416"><a href="#cb4-416"></a><span class="fu">#### Random residual variance</span></span>
<span id="cb4-417"><a href="#cb4-417"></a></span>
<span id="cb4-418"><a href="#cb4-418"></a><span class="in">    TITLE:</span></span>
<span id="cb4-419"><a href="#cb4-419"></a><span class="in">    fit_uSeed-000000_N-100_T-100_type-resid.random_Rep-1</span></span>
<span id="cb4-420"><a href="#cb4-420"></a></span>
<span id="cb4-421"><a href="#cb4-421"></a><span class="in">    DATA:</span></span>
<span id="cb4-422"><a href="#cb4-422"></a><span class="in">    FILE = "fit_uSeed-000000_N-100_T-100_type-resid.random_Rep-1.dat";</span></span>
<span id="cb4-423"><a href="#cb4-423"></a><span class="in">     </span></span>
<span id="cb4-424"><a href="#cb4-424"></a><span class="in">    VARIABLE:</span></span>
<span id="cb4-425"><a href="#cb4-425"></a><span class="in">    NAMES = subject t x; </span></span>
<span id="cb4-426"><a href="#cb4-426"></a><span class="in">    MISSING=.;</span></span>
<span id="cb4-427"><a href="#cb4-427"></a><span class="in">    CLUSTER = subject;</span></span>
<span id="cb4-428"><a href="#cb4-428"></a><span class="in">    LAGGED = x(1);</span></span>
<span id="cb4-429"><a href="#cb4-429"></a><span class="in">    TINTERVAL = t(1);</span></span>
<span id="cb4-430"><a href="#cb4-430"></a></span>
<span id="cb4-431"><a href="#cb4-431"></a><span class="in">    ANALYSIS:</span></span>
<span id="cb4-432"><a href="#cb4-432"></a><span class="in">    TYPE = TWOLEVEL RANDOM;</span></span>
<span id="cb4-433"><a href="#cb4-433"></a><span class="in">    ESTIMATOR = BAYES;</span></span>
<span id="cb4-434"><a href="#cb4-434"></a><span class="in">    PROCESSORS = 1;</span></span>
<span id="cb4-435"><a href="#cb4-435"></a><span class="in">    CHAINS = 2;</span></span>
<span id="cb4-436"><a href="#cb4-436"></a><span class="in">    THIN = 5;</span></span>
<span id="cb4-437"><a href="#cb4-437"></a><span class="in">    BITERATIONS = 5000(2000);</span></span>
<span id="cb4-438"><a href="#cb4-438"></a></span>
<span id="cb4-439"><a href="#cb4-439"></a><span class="in">    MODEL:</span></span>
<span id="cb4-440"><a href="#cb4-440"></a><span class="in">    %WITHIN%</span></span>
<span id="cb4-441"><a href="#cb4-441"></a><span class="in">    phi | x ON x&amp;1;</span></span>
<span id="cb4-442"><a href="#cb4-442"></a><span class="in">    logv | x;</span></span>
<span id="cb4-443"><a href="#cb4-443"></a><span class="in">    %BETWEEN%</span></span>
<span id="cb4-444"><a href="#cb4-444"></a><span class="in">    x phi logv WITH x phi logv;</span></span>
<span id="cb4-445"><a href="#cb4-445"></a></span>
<span id="cb4-446"><a href="#cb4-446"></a><span class="in">    OUTPUT:</span></span>
<span id="cb4-447"><a href="#cb4-447"></a><span class="in">    TECH1 TECH2 TECH3 TECH8 FSCOMPARISON STANDARDIZED STDYX STDY;</span></span>
<span id="cb4-448"><a href="#cb4-448"></a></span>
<span id="cb4-449"><a href="#cb4-449"></a><span class="in">    PLOT:</span></span>
<span id="cb4-450"><a href="#cb4-450"></a><span class="in">    TYPE = PLOT3;</span></span>
<span id="cb4-451"><a href="#cb4-451"></a><span class="in">    FACTORS = ALL (500);</span></span>
<span id="cb4-452"><a href="#cb4-452"></a></span>
<span id="cb4-453"><a href="#cb4-453"></a><span class="fu">#### Comparing different `ANALYSIS` parameters</span></span>
<span id="cb4-454"><a href="#cb4-454"></a></span>
<span id="cb4-455"><a href="#cb4-455"></a><span class="in">```{=html}</span></span>
<span id="cb4-456"><a href="#cb4-456"></a><span class="in">&lt;iframe width="700" height="500" src="./additional-files/hyperparameters.html" title="Quarto Documentation"&gt;&lt;/iframe&gt;</span></span>
<span id="cb4-457"><a href="#cb4-457"></a><span class="in">```</span></span>
<span id="cb4-458"><a href="#cb4-458"></a>:::</span>
<span id="cb4-459"><a href="#cb4-459"></a></span>
<span id="cb4-460"><a href="#cb4-460"></a><span class="fu">## The *Harvesting* component {#sec-harvesting-component}</span></span>
<span id="cb4-461"><a href="#cb4-461"></a></span>
<span id="cb4-462"><a href="#cb4-462"></a><span class="fu">## The *Reporting* component {#sec-reporting-component}</span></span>
<span id="cb4-463"><a href="#cb4-463"></a></span>
<span id="cb4-464"><a href="#cb4-464"></a><span class="fu"># Pipeline {#sec-pipeline}</span></span>
<span id="cb4-465"><a href="#cb4-465"></a></span>
<span id="cb4-466"><a href="#cb4-466"></a>We implemented each of these tasks in separate functions that were essentially wrapper functions (with parallel-computing implementation) around the modular components. Using these wrapper functions, each replication of each simulated condition was saved in a separate <span class="in">`.rds`</span> file. These data files were fed to the analysis wrapper function whose output was saved in separate <span class="in">`.rds`</span> data files. To collect relevant parameter estimates, another wrapper function was used to read the data files and save the desired parameters in a dataframe, which then used in reporting.</span>
<span id="cb4-467"><a href="#cb4-467"></a></span>
<span id="cb4-468"><a href="#cb4-468"></a><span class="fu">## Book-keeping {#sec-book-keeping}</span></span>
<span id="cb4-469"><a href="#cb4-469"></a></span>
<span id="cb4-470"><a href="#cb4-470"></a>The outcomes of the components are saved in separate <span class="in">`.rds`</span> files and indexed by unique, descriptive names, and each replication is given a unique numeric identifier that is also used as the random seed used to generate the dataset within each replication. The file names and address are stored in two dataframes along with model parameters used to generate each dataset, and these dataframes are used when reading and writing data files in other components.</span>
<span id="cb4-471"><a href="#cb4-471"></a></span>
<span id="cb4-472"><a href="#cb4-472"></a><span class="fu">## Wrapper functions {#sec-pipeline-wrapper-functions}</span></span>
<span id="cb4-473"><a href="#cb4-473"></a></span>
<span id="cb4-474"><a href="#cb4-474"></a><span class="fu">## Pipeline code {#sec-pipeline-code}</span></span>
<span id="cb4-475"><a href="#cb4-475"></a></span>
<span id="cb4-476"><a href="#cb4-476"></a><span class="fu"># Making the figures {#sec-figures}</span></span>
<span id="cb4-477"><a href="#cb4-477"></a></span>
<span id="cb4-478"><a href="#cb4-478"></a><span class="fu">## Simulation results</span></span>
<span id="cb4-479"><a href="#cb4-479"></a></span>
<span id="cb4-480"><a href="#cb4-480"></a><span class="fu">## Profiles of simulated datasets</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>